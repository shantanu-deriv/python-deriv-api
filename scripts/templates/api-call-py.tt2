# This file was automatically generated by [% scriptname %] at [% date %]
[%# Convert JSON schema API definition into a Python class %]

from numbers import Number

# =======================
# ----- API Methods -----
# =======================


class DerivAPICalls:
[% FOREACH m IN methods -%]

    async def [% m.method %](self, args=None):
        """
        [% m.description %]

        Parameters:
        -----------
            args : dict [% IF m.props %]with following keys[% END %]
[% FOREACH p IN m.props -%]
[% type = p.value.type -%]
[% SWITCH type -%]
[%   CASE 'integer' -%]
[% type = 'int' -%]
[%   CASE 'numeric' -%]
[% type = 'Number' -%]
[%   CASE 'string' -%]
[% type = 'str' -%]
[%   CASE 'boolean' -%]
[% type = 'bool' -%]
[%   CASE -%]
[% type = 'Any' -%]
[% END -%]
                [% p.key %] : [% type %]
[% IF p.value.description -%]
                    [% p.value.description %]
[% END -%]
[% END -%]
        """

        if args is None:
            args = {}

        config = [% m.encoded_props %]

        all_args = {
            'method': '[% m.method %]',
            'needs_method_arg': '[% m.needs_method_arg %]',
            'args': args,
            'config': config,
        }

        return await self.process_request(all_args)
[% END -%]

    async def process_request(self, all_args):
        """
        Process request
        """

        config = all_args['config']
        parsed_args = parse_args(all_args)
        error = validate_args(config=config, args=parsed_args)
        if error:
            raise ValueError(error)
        return await self.send(parsed_args)

__pdoc__ = {
    'parse_args' : False,
    'validate_args' : False,
    'deriv_api.deriv_api_calls.DerivAPICalls.process_request' : False
}

def parse_args(all_args):
    """
    Parse request args
    """

    parsed_args = all_args['args']
    method = all_args['method']
    
    if all_args['needs_method_arg'] and not(isinstance(parsed_args, dict)):
        parsed_args = {method: parsed_args}

    parsed_args[method] = parsed_args.get(method, 1)
    
    config = all_args['config']
    for param in parsed_args:
        value = parsed_args[param]
        if not (param in config):
            return

        ptype = config[param].get('type')
        if ptype and ptype == 'string':
            parsed_args[param] = f'{value}'
        elif ptype and (ptype == 'numeric' or ptype == 'boolean'):
            parsed_args[param] = int(float(value))
            
    return parsed_args


type_checkers = {
    'dict': lambda value: isinstance(value, dict),
    'numeric': lambda value: isinstance(value, Number),
    'string': lambda value: isinstance(value, str),
    'boolean': lambda value: value in [True, False, 0, 1],
    'integer': lambda value: isinstance(value, int)
}


def validate_args(config, args):
    """
    Validate request args
    """

    if not isinstance(args, dict):
        return f"Requires an dict but a {type(args)} is passed."

    error_messages = []
    missing = [k for k in config.keys() if (config.get(k) or {}).get('required') and not (k in args)]
    if len(missing):
        error_messages.append(f'Required parameters missing: {", ".join(missing)}')

    for param in args.keys():
        value = args[param]
        if param not in config:
            continue
        expected_type = config[param].get('type')

        if not expected_type:
            continue

        checker = type_checkers.get(expected_type)
        if not checker or not checker(value):
            error_messages.append(f'{expected_type} value expected but found {type(value)}: {param}')

    return ' - '.join(error_messages) if len(error_messages) else ''
